

 			.global LMS_isrOptsa

LMS_isrOptsa	.cproc	hp, xp, xp2, hp2, beta, cntr, newval
;passing pointers twice as we are constrained by speed rather than number of registers
		.reg	e, beta_e, a, b, p0, p1, sum0, sum1, y, deltah, newdelta
;Load the newval into the first position in the input array X

	STH newval, *xp
;Calc 1, Loop1 - dot product
LOOP1:	.trip 4,4
		LDW *hp++,a ; load ai & a1 from memory
		LDW *xp++,b ; load bi & b1 from memory
		MPY a,b,p0 ; ai * bi
		MPYH a,b,p1 ; ai+1 * bi+1
		ADD p0,sum0,sum0 ; sum0 += (ai * bi)
		ADD p1,sum1,sum1 ; sum1 += (ai+1 * bi+1)
		[cntr] SUB cntr,1,cntr ; decrement loop counter
		[cntr] B LOOP1 ; branch to loop
		ADD sum0, sum1, sum0
		SHR sum0, (15), y ; dot product of 16 bit values is 32 bit, need to left shift as the result has to be contained in a short

; Calc 2 - calculate error and beta_e
	SUB y, newval, e ; y-newval = e
	MPY beta, e, beta_e ; beta*e=beta_e(32)
	SHR beta_e, (15), beta_e; ; to allow 16 bit arithmetic

; second loop -> h_new = h + x*b_e
	PACK2 beta_e, beta_e, beta_e ; pack 2 16-bit beta_e's into a 32-bit register
LOOP2:	.trip 4,4

		LDW *hp2++,a ; load hi & hi+1 from memory
		LDW *xp2++,b ; load xi & xi+1 from memory
		MPY b, beta_e, p0;beta_e*xi
		MPYH b, beta_e, p1;beta_e*xi+1
		SHR p0, (15), p0 ; product of 16 bit values is 32 bit, need to left shift as the result has to be contained in a short
		SHR p1, (15), p1 ; product of 16 bit values is 32 bit, need to left shift as the result has to be contained in a short
		PACK2 p0, p1, deltah ; for add2 addition
		ADD2 a, deltah, newdelta ;
		STW newdelta, *hp2 ;need to check how to reference correct offset

		; shift the x array
		[cntr] SUB cntr,1,cntr ; decrement loop counter
		[cntr] B LOOP1 ; branch to loop


	.return y
 		.endproc


